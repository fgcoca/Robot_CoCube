module main
author unknown
version 1 0 
description ''

script 100 58 {
whenStarted
'ccmodule_power on module'
'Sentry2 init' 96
waitMillis 4000
'Sentry turn' 'apriltag' true
}

script 390 62 {
whenCondition true
if ((Sentry2_detect_result 0) == 1) {
  sayIt 'X:' ('Sentry detect normalobj' 1 'X') ('[data:unicodeString]' 10) 'Y:' ('Sentry detect normalobj' 1 'Y') ('[data:unicodeString]' 10) 'Ancho:' ('Sentry detect normalobj' 1 'width') ('[data:unicodeString]' 10) 'Alto:' ('Sentry detect normalobj' 1 'heigh') ('[data:unicodeString]' 10) 'Número:' ('Sentry detect normalobj' 1 'label')
}
}


module CoCube
author 'Liang Shuai'
version 2 11 
depends Tone Display TFT 'Motors/PID' 
tags 'cocube robot' 
choices cocube_rotate_Menu 'cocube;left' 'cocube;right' 
choices cocube_move_Menu 'cocube;forward' 'cocube;backward' 
description 'CoCube Robot library

CoCube is a tabletop modular multi-robot platform for education and research.
https://www.cocubefun.com/
sliang23@m.fudan.edu.cn

v1.0 Basic functions
v2.0 Comprehensively add encoder control motor function
v2.1 Fix some bugs caused by broadcasting
v2.2 Improve positioning accuracy to 1/128
v2.3 Add blocks prompts
v2.4 Unify positioning accuracy to 1/64
v2.5 Adjust blocks order and delete RingTone
v2.6 Adjust blocks order, name and default parameters
v2.11 Improve the "CoCube move to" function logic
'
variables _cocube_set_right_speed _cocube_set_left_speed _cocube_error_angle _cocube_pid_i _cocube_pid_ratio _cocube_pid_initialized _cocube_pid_d _cocube_pid_p _cocube_error_distance _cocube_error_y _cocube_error_x _cocube_target_angle 

  spec ' ' 'CoCube move for msecs' 'move _ at _ speed (0-50) for _ msecs' 'menu.cocube_move_Menu num num' 'cocube;forward' 40 1000
  spec ' ' 'CoCube rotate for msecs' 'rotate _ at _ speed (0-50) for _ msecs' 'menu.cocube_rotate_Menu num num' 'cocube;left' 30 1000
  space
  spec ' ' 'CoCube move' 'move _ at _ speed (0-50)' 'menu.cocube_move_Menu num' 'cocube;forward' 40
  spec ' ' 'CoCube rotate' 'rotate _ at _ speed (0-50)' 'menu.cocube_rotate_Menu num' 'cocube;left' 30
  spec ' ' 'CoCube set wheel' 'set wheel left _ right _ (-50 to 50)' 'num num' 40 20
  space
  spec ' ' 'CoCube wheels stop' 'wheels stop'
  spec ' ' 'CoCube wheels break' 'wheels break'
  space
  spec 'r' 'CoCube position_X' 'X position'
  spec 'r' 'CoCube position_Y' 'Y position'
  spec 'r' 'CoCube direction' 'direction'
  space
  spec ' ' 'CoCube move by step' 'move _ at _ speed (0-50) by _ steps' 'menu.cocube_move_Menu num num' 'cocube;forward' 40 50
  spec ' ' 'CoCube rotate by degree' 'rotate _ at _ speed (0-50) by _ degrees' 'menu.cocube_rotate_Menu num num' 'cocube;left' 30 90
  space
  spec ' ' 'CoCube rotate to angle' 'rotate to angle _ at _ speed (0-50)' 'num num' 0 30
  spec ' ' 'CoCube point towards' 'point towards X _ Y _ at _ speed (0-50)' 'num num num' 0 0 30
  spec ' ' 'CoCube move to' 'move to X _ Y _ at _ speed (0-50)' 'num num num' 0 0 40
  space
  spec 'r' 'CoCube on the mat' 'on the mat'
  spec 'r' 'CoCube card ID' 'card ID'
  space
  spec ' ' 'CoCube draw ArUco marker on TFT' 'draw ArUco marker on TFT _' 'num' 0
  spec ' ' 'CoCube draw AprilTag on TFT' 'draw AprilTag on TFT _' 'num' 0
  spec ' ' 'CoCube set TFT backlight' 'set TFT backlight _' 'bool' false
  space
  spec 'r' 'CoCube battery percentage' 'battery percentage'
  space
  spec ' ' '_cocube_motors_speed' '_cocube_motors_speed left _ right _' 'num num' 10 10
  spec ' ' '_cocube_pid_init' '_cocube_pid_init'
  spec ' ' '_cocube_pid_left_motor' '_cocube_pid_left_motor'
  spec ' ' '_cocube_pid_right_motor' '_cocube_pid_right_motor'
  spec ' ' '_cocube_calculate_angle_error_' '_cocube_calculate_angle_error angle _' 'num' 0
  spec ' ' '_cocube_calculate_distance_error target_x _ target_y _' '_cocube_calculate_distance_error Target_X _ Target_Y _' 'num num' 0 0

to 'CoCube battery percentage' {
  return (minimum (((254 * ('[misc:rescale]' (analogReadOp 34) 0 1023 0 3300)) - 680000) / 1600) 100)
}

to 'CoCube card ID' {
  return (callCustomReporter '[sensors:cube_index]')
}

to 'CoCube direction' {
  return (callCustomReporter '[sensors:position_yaw]')
}

to 'CoCube draw AprilTag on TFT' id {
  comment '0 <= id < 100'
  if (id >= 100) {
    sayIt '0 <= id < 100'
  } else {
    callCustomCommand '[tft:aprilTag]' ('[data:makeList]' id)
  }
}

to 'CoCube draw ArUco marker on TFT' id {
  comment '0 <= id < 100'
  if (id >= 100) {
    sayIt '0 <= id < 100'
  } else {
    callCustomCommand '[tft:aruco]' ('[data:makeList]' id)
  }
}

to 'CoCube move' direction speed {
  if (direction == 'cocube;forward') {
    'CoCube set wheel' speed speed
  } else {
    'CoCube set wheel' (0 - speed) (0 - speed)
  }
}

to 'CoCube move by step' direction speed steps {
  if ('CoCube on the mat') {
    local 'begin_x' ('CoCube position_X')
    local 'begin_y' ('CoCube position_Y')
    'CoCube move' direction speed
    forever {
      '_cocube_calculate_distance_error target_x _ target_y _' begin_x begin_y
      if ((steps - _cocube_error_distance) < 2) {
        'CoCube wheels break'
        comment 'wait for break function 200ms'
        waitMillis 210
        return 0
      }
    }
  } else {
    sayIt 'Please put CoCube on Mat'
  }
}

to 'CoCube move for msecs' direction speed time {
  'CoCube move' direction speed
  waitMillis time
  'CoCube wheels break'
}

to 'CoCube move to' target_x target_y speed {
  if ('CoCube on the mat') {
    speed = speed
    '_cocube_calculate_distance_error target_x _ target_y _' target_x target_y
    if (_cocube_error_distance > 7) {
      'CoCube point towards' target_x target_y speed
      repeatUntil (_cocube_error_distance < 7) {
        '_cocube_calculate_distance_error target_x _ target_y _' target_x target_y
        _cocube_target_angle = (('[misc:atan2]' _cocube_error_y _cocube_error_x) / 100)
        '_cocube_calculate_angle_error_' _cocube_target_angle
        'CoCube set wheel' (speed - ((speed * _cocube_error_angle) / 20)) (speed + ((speed * _cocube_error_angle) / 20))
        waitMillis 10
      }
      'CoCube wheels break'
      return 0
    }
  } else {
    sayIt 'Please put CoCube on Mat'
  }
}

to 'CoCube on the mat' {
  return (callCustomReporter '[sensors:cube_status]')
}

to 'CoCube point towards' target_x target_y speed {
  _cocube_target_angle = (('[misc:atan2]' (target_y - ('CoCube position_Y')) (target_x - ('CoCube position_X'))) / 100)
  'CoCube rotate to angle' _cocube_target_angle speed
}

to 'CoCube position_X' {
  return ((callCustomReporter '[sensors:position_x]') / 64)
}

to 'CoCube position_Y' {
  return ((callCustomReporter '[sensors:position_y]') / 64)
}

to 'CoCube rotate' direction speed {
  if (direction == 'cocube;left') {
    'CoCube set wheel' (0 - speed) speed
  } else {
    'CoCube set wheel' speed (0 - speed)
  }
}

to 'CoCube rotate by degree' direction speed degree {
  if ('CoCube on the mat') {
    local 'begin_degree' ('CoCube direction')
    forever {
      if (direction == 'cocube;left') {
        '_cocube_calculate_angle_error_' (begin_degree + degree)
      } else {
        '_cocube_calculate_angle_error_' (begin_degree - degree)
      }
      if (_cocube_error_angle > 1) {
        comment 'turn left'
        '_cocube_motors_speed' (0 - speed) speed
      } (_cocube_error_angle < -1) {
        comment 'turn right'
        '_cocube_motors_speed' speed (0 - speed)
      } else {
        comment 'motors break'
        '_cocube_motors_speed' -99 -99
        return 0
      }
    }
  } else {
    sayIt 'Please put CoCube on Mat'
  }
}

to 'CoCube rotate for msecs' direction speed time {
  'CoCube rotate' direction speed
  waitMillis time
  'CoCube wheels break'
}

to 'CoCube rotate to angle' angle speed {
  if ('CoCube on the mat') {
    local 'abs_speed' (absoluteValue speed)
    forever {
      '_cocube_calculate_angle_error_' angle
      if (_cocube_error_angle > 1) {
        comment 'turn left'
        '_cocube_motors_speed' (0 - abs_speed) abs_speed
      } (_cocube_error_angle < -1) {
        comment 'turn right'
        '_cocube_motors_speed' abs_speed (0 - abs_speed)
      } else {
        comment 'motors break'
        '_cocube_motors_speed' -99 -99
        return 0
      }
    }
  } else {
    sayIt 'Please put CoCube on Mat'
  }
}

to 'CoCube set TFT backlight' state {
  if state {
    '[tft:setBacklight]' 10
  } else {
    '[tft:setBacklight]' 0
  }
}

to 'CoCube set wheel' speed_left speed_right {
  _cocube_set_left_speed = speed_left
  _cocube_set_right_speed = speed_right
  sendBroadcast '_cocube_pid_left_motor'
  sendBroadcast '_cocube_pid_right_motor'
}

to 'CoCube wheels break' {
  'CoCube set wheel' -99 -99
}

to 'CoCube wheels stop' {
  'CoCube set wheel' 0 0
}

to '_cocube_calculate_angle_error_' angle {
  _cocube_error_angle = ((angle % 360) - ('CoCube direction'))
  if (_cocube_error_angle > 180) {
    _cocube_error_angle += -360
  } (_cocube_error_angle < -180) {
    _cocube_error_angle += 360
  }
}

to '_cocube_calculate_distance_error target_x _ target_y _' target_x target_y {
  _cocube_error_x = (target_x - ('CoCube position_X'))
  _cocube_error_y = (target_y - ('CoCube position_Y'))
  _cocube_error_distance = ('[misc:sqrt]' ((_cocube_error_x * _cocube_error_x) + (_cocube_error_y * _cocube_error_y)))
}

to '_cocube_motors_speed' left_speed right_speed {
  comment 'without pid control'
  if (and (left_speed == 0) (right_speed == 0)) {
    digitalWriteOp 9 false
    digitalWriteOp 10 false
    digitalWriteOp 26 false
    digitalWriteOp 25 false
  } (and (left_speed == -99) (right_speed == -99)) {
    digitalWriteOp 9 true
    digitalWriteOp 10 true
    digitalWriteOp 26 true
    digitalWriteOp 25 true
    waitMillis 200
    digitalWriteOp 9 false
    digitalWriteOp 10 false
    digitalWriteOp 26 false
    digitalWriteOp 25 false
  } else {
    if (left_speed > 0) {
      analogWriteOp 9 ((4 * (absoluteValue left_speed)) + 36)
      digitalWriteOp 10 false
    } else {
      digitalWriteOp 9 false
      analogWriteOp 10 ((4 * (absoluteValue left_speed)) + 36)
    }
    if (right_speed > 0) {
      analogWriteOp 26 ((4 * (absoluteValue right_speed)) + 36)
      digitalWriteOp 25 false
    } else {
      digitalWriteOp 26 false
      analogWriteOp 25 ((4 * (absoluteValue right_speed)) + 36)
    }
  }
}

to '_cocube_pid_init' {
  if (not _cocube_pid_initialized) {
    _cocube_pid_p = 320
    _cocube_pid_i = 1
    _cocube_pid_d = 3
    _cocube_pid_ratio = 1000
    _cocube_pid_initialized = 1
  }
}

to '_cocube_pid_left_motor' {
  '_cocube_pid_init'
  pid_resetPID 1
  local 'var' 0
  forever {
    if (_cocube_set_left_speed == 0) {
      comment 'speed = 0 :motor stop'
      digitalWriteOp 9 false
      digitalWriteOp 10 false
      return 0
    } (_cocube_set_left_speed == -99) {
      comment 'speed = -99 : motor break'
      digitalWriteOp 9 true
      digitalWriteOp 10 true
      waitMillis 200
      digitalWriteOp 9 false
      digitalWriteOp 10 false
      return 0
    } else {
      comment 'PID control'
      var = ((((4 * (absoluteValue _cocube_set_left_speed)) + 36) + (pid_computePID 1 ((18 * (absoluteValue _cocube_set_left_speed)) - (callCustomReporter '[sensors:speed_left]')) _cocube_pid_p _cocube_pid_i _cocube_pid_d 0)) / _cocube_pid_ratio)
      if (_cocube_set_left_speed > 0) {
        analogWriteOp 9 var
        digitalWriteOp 10 false
      } else {
        analogWriteOp 10 var
        digitalWriteOp 9 false
      }
    }
  }
}

to '_cocube_pid_right_motor' {
  '_cocube_pid_init'
  pid_resetPID 2
  local 'var' 0
  forever {
    if (_cocube_set_right_speed == 0) {
      comment 'speed = 0 :motor stop'
      digitalWriteOp 26 false
      digitalWriteOp 25 false
      return 0
    } (_cocube_set_right_speed == -99) {
      comment 'speed = -99 : motor break'
      digitalWriteOp 26 true
      digitalWriteOp 25 true
      waitMillis 200
      digitalWriteOp 26 false
      digitalWriteOp 25 false
      return 0
    } else {
      comment 'PID control'
      var = ((((4 * (absoluteValue _cocube_set_right_speed)) + 36) + (pid_computePID 2 ((18 * (absoluteValue _cocube_set_right_speed)) - (callCustomReporter '[sensors:speed_right]')) _cocube_pid_p _cocube_pid_i _cocube_pid_d 0)) / _cocube_pid_ratio)
      if (_cocube_set_right_speed > 0) {
        analogWriteOp 26 var
        digitalWriteOp 25 false
      } else {
        analogWriteOp 25 var
        digitalWriteOp 26 false
      }
    }
  }
}


module 'CoCube Module'
author 'Liang Shuai'
version 1 9 
depends Servo NeoPixel 'Robots/CoCube' 'Sensing/Distance (VL53L0X)' 'Sensing/Gesture (PAJ7620)' 
description 'External modules of CoCube.

CoCube is a tabletop modular multi-robot platform for education and research.
https://www.cocubefun.com/
sliang23@m.fudan.edu.cn

Note: All functions start by turning on pin 13 to power the module.
The power pin is off by default and is also turned off by the IDE stop button.'
variables ccmodule_lastDistance 

  spec ' ' 'ccmodule_gripper open' 'gripper open'
  spec ' ' 'ccmodule_gripper close' 'gripper close'
  spec ' ' 'ccmodule_gripper degree' 'gripper degrees _ (0 to 70)' 'num' 0
  space
  spec ' ' 'ccmodule_attach NeoPixels' 'attach NeoPixels'
  spec ' ' 'ccmodule_set all NeoPixels color' 'set all NeoPixels color _' 'color'
  spec ' ' 'ccmodule_clear NeoPixels' 'clear NeoPixels'
  space
  spec 'r' 'ccmodule_ToF connected' 'ToF connected'
  spec 'r' 'ccmodule_ToF distance' 'ToF distance (mm)'
  space
  spec 'r' 'ccmodule_gesture connected' '3D gesture connected'
  spec 'r' 'ccmodule_gesture read' '3D gesture read'
  space
  spec ' ' 'ccmodule_power on module' 'power on module'
  space
  spec 'r' '_ccmodule_ultrasonic distance' 'ultrasonic distance (mm)'

to '_ccmodule_ultrasonic distance' {
  local 'trig' 21
  local 'echo' 22
  comment 'Reset pulse capture system.'
  local 'ignore' ('[sensors:captureEnd]')
  digitalWriteOp trig false
  waitMicros 2
  digitalWriteOp trig true
  waitMicros 50
  digitalWriteOp trig false
  comment 'Wait for a low-to-high edge on the echo pin.
Timeout if an edge is not detected. '
  local 'start' (millisOp)
  waitUntil (or (not (digitalReadOp echo)) ((millisSince start) > 2))
  waitUntil (or (digitalReadOp echo) ((millisSince start) > 2))
  if ((millisSince start) > 2) {
    comment 'Distance sensor not ready; return the last distance reading'
    return ccmodule_lastDistance
  }
  comment 'Starting pulse was sent. Measure time until echo is detected.'
  '[sensors:captureStart]' echo
  start = (millisOp)
  waitUntil (or (('[sensors:captureCount]') > 0) ((millisSince start) > 25))
  comment 'Default value of 23320 usecs reports 4000 mm
when no echo is detected.'
  local 'echoMicrosecs' 23320
  if (('[sensors:captureCount]') > 0) {
    echoMicrosecs = (absoluteValue (at 1 ('[sensors:captureEnd]')))
  }
  ccmodule_lastDistance = ((100 * echoMicrosecs) / 583)
  comment 'Leave some time for reverberations to die away.'
  waitMillis 10
  return ccmodule_lastDistance
}

to 'ccmodule_ToF connected' {
  stopServo 22
  digitalWriteOp 13 true
  return ('VL53L0X connected')
}

to 'ccmodule_ToF distance' {
  stopServo 22
  digitalWriteOp 13 true
  return ('VL53L0X distance (mm)')
}

to 'ccmodule_attach NeoPixels' {
  stopServo 22
  digitalWriteOp 13 true
  waitMillis 10
  neoPixelAttach 48 22
}

to 'ccmodule_clear NeoPixels' {
  digitalWriteOp 13 true
  clearNeoPixels
}

to 'ccmodule_gesture connected' {
  stopServo 22
  digitalWriteOp 13 true
  return ('paj7620 connected')
}

to 'ccmodule_gesture read' {
  stopServo 22
  digitalWriteOp 13 true
  return ('paj7620 read')
}

to 'ccmodule_gripper close' {
  digitalWriteOp 13 true
  setServoAngle 22 -70
}

to 'ccmodule_gripper degree' degree {
  digitalWriteOp 13 true
  local 'var' (degree - 70)
  if (var < -70) {
    setServoAngle 22 -70
  } (var > 0) {
    setServoAngle 22 0
  } else {
    setServoAngle 22 var
  }
}

to 'ccmodule_gripper open' {
  digitalWriteOp 13 true
  setServoAngle 22 0
}

to 'ccmodule_power on module' {
  digitalWriteOp 13 true
}

to 'ccmodule_set all NeoPixels color' color {
  digitalWriteOp 13 true
  neoPixelSetAllToColor color
}


module 'Distance (VL53L0X)' Input
author 'José García Yeste'
version 1 2 
tags sensor distance 
description 'Support for VL53L0X distance sensor.
TOF laser based.
Range 3-200mm.

Tested on:
https://shop.m5stack.com/products/tof-sensor-unit (take Kapton tape on sensor!)
'

  spec 'r' 'VL53L0X connected' 'VL53L0X connected'
  spec 'r' 'VL53L0X distance (mm)' 'VL53L0X distance (mm)'

to 'VL53L0X connected' {
  return ((i2cGet 41 (hexToInt 'C0')) == (hexToInt 'EE'))
}

to 'VL53L0X distance (mm)' {
  i2cSet 41 0 1
  waitMillis 70
  if (((i2cGet 41 (hexToInt '14')) & 1) == 1) {
    '[sensors:i2cWrite]' 41 ('[data:makeList]' (hexToInt '14'))
    local 'buf' (newList 12)
    '[sensors:i2cRead]' 41 buf
    if ((at 1 buf) == 95) {
      return (((at 11 buf) << 8) | (at 12 buf))
    } else {
      return -1
    }
  } else {
    return -2
  }
}


module 'Gesture (PAJ7620)' Input
author 'José García'
version 1 1 
tags sensor gesture 
description 'Support for PAJ7620 gesture sensor.
The "read" block returns the name of the detected gesture.
Based on github.com/Seeed-Studio/Gesture_PAJ7620'
variables '_paj7620 initialized' 

  spec 'r' 'paj7620 read' 'paj7620 read'
  spec ' ' '_paj7620 setup' '_paj7620 setup'
  spec 'r' 'paj7620 connected' 'paj7620 connected'
  spec ' ' '_paj7620 setup bank0' '_paj7620 setup bank0'
  spec ' ' '_paj7620 setup bank1' '_paj7620 setup bank1'

to '_paj7620 setup' {
  if ('paj7620 connected') {
    '_paj7620 setup bank0'
    '_paj7620 setup bank1'
    i2cSet (hexToInt '73') (hexToInt '65') (hexToInt '12')
    i2cSet (hexToInt '73') (hexToInt 'EF') 0
    '_paj7620 initialized' = 1
  }
}

to '_paj7620 setup bank0' {
  i2cSet (hexToInt '73') (hexToInt 'EF') 0
  local 'i' 1
  local 'list' '3229
3301
3400
3501
3600
3707
3817
3906
3A12
3F00
4002
41FF
4201
462D
470F
483C
4900
4A1E
4B00
4C20
4D00
4E1A
4F14
5000
5110
5200
5C02
5D00
5E10
5F3F
6027
6128
6200
6303
64F7
6503
66D9
6703
6801
69C8
6A40
6D04
6E00
6F00
7080
7100
7200
7300
74F0
7500
8042
8144
8204
8320
8420
8500
8610
8700
8805
8918
8A10
8B01
8C37
8D00
8EF0
8F81
9006
9106
921E
930D
940A
950A
960C
9705
980A
9941
9A14
9B0A
9C3F
9D33
9EAE
9FF9
A048
A113
A210
A308
A430
A519
A610
A708
A824
A904
AA1E
AB1E
CC19
CD0B
CE13
CF64
D021
D10F
D288
E001
E104
E241
E3D6
E400
E50C
E60A
E700
E800
E900
EE07'
  repeatUntil (i > (size list)) {
    local 'reg' ('[data:copyFromTo]' list i (i + 1))
    local 'val' ('[data:copyFromTo]' list (i + 2) (i + 4))
    i2cSet (hexToInt '73') (hexToInt reg) (hexToInt val)
    i += 5
    waitMicros 10
  }
}

to '_paj7620 setup bank1' {
  i2cSet (hexToInt '73') (hexToInt 'EF') 1
  local 'i' 1
  local 'list' '001E
011E
020F
0310
0402
0500
06B0
0704
080D
090E
0A9C
0B04
0C05
0D0F
0E02
0F12
1002
1102
1200
1301
1405
1507
1605
1707
1801
1904
1A05
1B0C
1C2A
1D01
1E00
2100
2200
2300
2501
2600
2739
287F
2908
3003
3100
321A
331A
3407
3507
3601
37FF
3836
3907
3A00
3EFF
3F00
4077
4140
4200
4330
44A0
455C
4600
4700
4858
4A1E
4B1E
4C00
4D00
4EA0
4F80
5000
5100
5200
5300
5400
5780
5910
5A08
5B94
5CE8
5D08
5E3D
5F99
6045
6140
632D
6402
6596
6600
6797
6801
69CD
6A01
6BB0
6C04
6D2C
6E01
6F32
7100
7201
7335
7400
7533
7631
7701
7C84
7D03
7E01'
  repeatUntil (i > (size list)) {
    local 'reg' ('[data:copyFromTo]' list i (i + 1))
    local 'val' ('[data:copyFromTo]' list (i + 2) (i + 4))
    i2cSet (hexToInt '73') (hexToInt reg) (hexToInt val)
    i += 5
    waitMicros 10
  }
}

to 'paj7620 connected' {
  return (and ((i2cGet (hexToInt '73') 0) == 32) ((i2cGet (hexToInt '73') 1) == 118))
}

to 'paj7620 read' {
  if ((v '_paj7620 initialized') == 0) {'_paj7620 setup'}
  local 'msg' '?'
  local 'g' (i2cGet (hexToInt '73') (hexToInt '43'))
  if ((g & 1) != 0) {
    msg = 'right'
  } ((g & 2) != 0) {
    msg = 'left'
  } ((g & 4) != 0) {
    msg = 'up'
  } ((g & 8) != 0) {
    msg = 'down'
  } ((g & 16) != 0) {
    msg = 'forward'
  } ((g & 32) != 0) {
    msg = 'backward'
  } ((g & 64) != 0) {
    msg = 'clockwise'
  } ((g & 128) != 0) {
    msg = 'anti-clockwise'
  }
  return msg
}


module 'LED Display' Output
author MicroBlocks
version 1 13 
choices led_imageMenu heart 'small heart' yes no happy sad confused angry asleep surprised silly fabulous meh 't-shirt' 'roller skate' duck house tortoise butterfly 'stick figure' ghost sword giraffe skull umbrella snake rabbit cow 'quarter note' 'eight note' pitchfork target triangle 'left triangle' 'chess board' diamond 'small diamond' square 'small square' scissors 
description 'Display primitives for the 5x5 LED display on the BBC micro:bit, Calliope mini and M5Atom Matrix. Boards with TFT displays (such as the Citilab ED1 or the M5Stack family) support these primitives with a simulated "fat pixel" display.
'
variables _stop_scrolling_text 

  spec ' ' '[display:mbDisplay]' 'display _' 'microbitDisplay' 15237440
  spec ' ' 'led_displayImage' 'display image _ : x _ y _' 'menu.led_imageMenu num num' 'happy' 1 1
  spec ' ' '[display:mbDisplayOff]' 'clear display'
  space
  spec ' ' '[display:mbPlot]' 'plot x _ y _' 'num num' 3 3
  spec ' ' '[display:mbUnplot]' 'unplot x _ y _' 'num num' 3 3
  space
  spec ' ' 'displayCharacter' 'display character _' 'str' 'A'
  spec ' ' 'scroll_text' 'scroll text _ : pausing _ ms' 'str num' 'HELLO ROSA!' 100
  spec ' ' 'stopScrollingText' 'stop scrolling'
  advanced
  spec ' ' 'set display color' 'set display color _' 'color'
  spec 'r' 'led_image' 'led image _' 'microbitDisplay' 15237440
  space
  spec 'r' '_led_namedImage' '_led_namedImage _' 'menu.led_imageMenu' 'happy'
  spec 'r' '_led_imageData' '_led_imageData'

to '_led_imageData' {
  return 'heart:4685802,small heart:145728,yes:2269696,no:18157905,happy:15237440,sad:18284864,confused:22348096,angry:23036241,asleep:459616,surprised:4526090,silly:25984017,fabulous:15008639,meh:2236443,t-shirt:15154043,roller skate:11534104,duck:489702,house:10976708,tortoise:359872,butterfly:29332475,stick figure:18158564,ghost:23068334,sword:4657284,giraffe:10946627,skull:15171246,umbrella:6460398,snake:469859,rabbit:16104613,cow:4685361,quarter note:7573636,eight note:7590276,pitchfork:4357813,target:4681156,triangle:1026176,left triangle:32805985,chess board:11184810,diamond:4539716,small diamond:141440,square:33080895,small square:469440,scissors:20287859,'
}

to '_led_namedImage' name {
  local 'data' ('_led_imageData')
  local 'i' ('[data:find]' name data)
  if (i == -1) {
    comment 'Name not found'
    return 0
  }
  local 'start' (('[data:find]' ':' data i) + 1)
  local 'end' (('[data:find]' ',' data i) - 1)
  return ('[data:convertType]' ('[data:copyFromTo]' data start end) 'number')
}

to displayCharacter s {
  s = ('[data:join]' '' s)
  if ((size s) == 0) {
    '[display:mbDisplayOff]'
    return 0
  }
  '[display:mbDrawShape]' ('[display:mbShapeForLetter]' (at 1 s)) 1 1
}

to led_displayImage imageName optionalX optionalY {
  local 'image' imageName
  if (isType image 'string') {
    image = ('_led_namedImage' imageName)
  }
  '[display:mbDrawShape]' image (argOrDefault 2 1) (argOrDefault 3 1)
}

to led_image twentyFiveBitInt {
  comment 'An LED image is a 25-bit integer'
  return twentyFiveBitInt
}

to scroll_text text optionalDelay {
  text = ('[data:join]' '' text)
  local 'delay' 100
  if ((pushArgCount) > 1) {
    delay = optionalDelay
  }
  _stop_scrolling_text = (booleanConstant false)
  if ('Pico:ed' == (boardType)) {
    for position (((size text) * 6) + 18) {
      if _stop_scrolling_text {return 0}
      '[display:mbDisplayOff]'
      '[tft:text]' text (17 - position) 0 (colorSwatch 125 125 125 255) 1 true
      waitMillis (delay / 2)
    }
  } ('kidsIOT' == (boardType)) {
    for position (((size text) * 6) + 21) {
      if _stop_scrolling_text {return 0}
      '[tft:deferUpdates]'
      '[tft:clear]'
      '[tft:text]' text (128 - (6 * position)) 6 (colorSwatch 255 255 255 255) 6 false
      '[tft:resumeUpdates]'
      waitMillis (delay / 8)
    }
  } else {
    for position (((size text) * 6) + 6) {
      if _stop_scrolling_text {return 0}
      for i (size text) {
        '[display:mbDrawShape]' ('[display:mbShapeForLetter]' ('[data:unicodeAt]' i text)) (((i * 6) + 2) - position) 1
      }
      waitMillis delay
    }
  }
}

to 'set display color' color {
  '[display:mbSetColor]' color
}

to stopScrollingText {
  _stop_scrolling_text = (booleanConstant true)
  waitMillis 10
  '[display:mbDisplayOff]'
}


module NeoPixel Output
author MicroBlocks
version 1 14 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels _np_pin _np_haswhite 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'setNeoPixelColors25' 'set NeoPixels #BR# _ _ _ _ _ #BR# _ _ _ _ _ #BR# _ _ _ _ _ #BR# _ _ _ _ _ #BR# _ _ _ _ _' 'color color color color color color color color color color color color color color color color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'neoPixel_colorSwatch' '_' 'color'
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  space
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  spec ' ' 'NeoPixel_shift_color' 'shift NeoPixel _ color by _' 'num num' 1 10
  spec ' ' 'NeoPixel_shift_all_colors' 'shift all NeoPixel colors by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'
  spec ' ' '_NeoPixel_shift_hue' '_NeoPixel_shift_hue of _ by _' 'auto auto' '10' '10'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to NeoPixel_shift_all_colors delta {
  for i (size _np_pixels) {
    '_NeoPixel_shift_hue' i delta
  }
  '_NeoPixel_update'
}

to NeoPixel_shift_color i delta {
  '_NeoPixel_shift_hue' i delta
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if (or ((boardType) == 'M5Atom-Matrix') (or ((boardType) == 'Mbits') ((boardType) == 'micro:STEAMakers'))) {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'FOXBIT') {
    neoPixelAttach 35 '' false
  } ((boardType) == 'CodingBox') {
    neoPixelAttach 35 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'h' ('[misc:hue]' rgb)
    local 's' ('[misc:saturation]' rgb)
    local 'v' (('[misc:brightness]' rgb) + delta)
    v = (maximum 20 (minimum v 100))
    atPut i _np_pixels ('[misc:hsvColor]' h s v)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_shift_hue' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'h' ((('[misc:hue]' rgb) + delta) % 360)
    local 's' ('[misc:saturation]' rgb)
    local 'v' ('[misc:brightness]' rgb)
    atPut i _np_pixels ('[misc:hsvColor]' h s v)
  }
}

to '_NeoPixel_update' {
  comment 'NeoPixel pin and hasWhite may have been changed by another library.'
  '[display:neoPixelSetPin]' _np_pin _np_hasWhite
  '[display:neoPixelSend]' _np_pixels
  waitMicros 300
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  atPut 'all' _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  _np_pin = pinNumber
  _np_hasWhite = false
  if ((pushArgCount) > 2) {
    _np_hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  atPut 'all' _np_pixels 0
  '[display:neoPixelSetPin]' _np_pin _np_hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  atPut 'all' _np_pixels color
  '_NeoPixel_update'
}

to neoPixel_colorSwatch color {
  return color
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  local 'rotateLeft' (n < 0)
  if (or ((boardType) == 'CircuitPlayground') ((boardType) == 'CircuitPlayground Bluefruit')) {
    rotateLeft = (n > 0)
  }
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' rotateLeft
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}

to setNeoPixelColors25 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15 c16 c17 c18 c19 c20 c21 c22 c23 c24 c25 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  if ((size _np_pixels) >= 11) {
    atPut 11 _np_pixels c11
  }
  if ((size _np_pixels) >= 12) {
    atPut 12 _np_pixels c12
  }
  if ((size _np_pixels) >= 13) {
    atPut 13 _np_pixels c13
  }
  if ((size _np_pixels) >= 14) {
    atPut 14 _np_pixels c14
  }
  if ((size _np_pixels) >= 15) {
    atPut 15 _np_pixels c15
  }
  if ((size _np_pixels) >= 16) {
    atPut 16 _np_pixels c16
  }
  if ((size _np_pixels) >= 17) {
    atPut 17 _np_pixels c17
  }
  if ((size _np_pixels) >= 18) {
    atPut 18 _np_pixels c18
  }
  if ((size _np_pixels) >= 19) {
    atPut 19 _np_pixels c19
  }
  if ((size _np_pixels) >= 20) {
    atPut 20 _np_pixels c20
  }
  if ((size _np_pixels) >= 21) {
    atPut 21 _np_pixels c21
  }
  if ((size _np_pixels) >= 22) {
    atPut 22 _np_pixels c22
  }
  if ((size _np_pixels) >= 23) {
    atPut 23 _np_pixels c23
  }
  if ((size _np_pixels) >= 24) {
    atPut 24 _np_pixels c24
  }
  if ((size _np_pixels) >= 25) {
    atPut 25 _np_pixels c25
  }
  '_NeoPixel_update'
}


module PID Operators
author 'Russell Owen'
version 0 9 
description 'PID Control Loop'
variables _pid__initialized _pid__numPIDs _pid__prevError _pid__prevMicros _pid__prevIntegral 

  spec 'r' 'pid_computePID' 'compute pid at index _ error _ p coeff _ i coeff _ d coeff _ max integral _ (ignored if 0)' 'num num num num num num' 1 0 1 0 0 0
  spec ' ' 'pid_resetPID' 'reset pid at index _' 'num' 1
  space
  spec 'r' 'pid_constrainValue' 'constrain value _ deadband _ minimum _ maximum _' 'num num num num' 0 0 0 1000
  spec 'r' 'pid_applySign' 'apply sign of _ to value _' 'num num' 1 0
  space
  spec ' ' '_pid_extendPIDLists' '_extend pid lists; index _' 'num' 1
  spec ' ' '_pid_initLibrary' '_init pid library'

to '_pid_extendPIDLists' index {
  comment 'Extend global list variables, if needed,
so that they are large enough to use the specified index.'
  '_pid_initLibrary'
  repeatUntil ((size _pid__prevError) >= index) {
    '[data:addLast]' 0 _pid__prevError
    '[data:addLast]' -1 _pid__prevMicros
    '[data:addLast]' 0 _pid__prevIntegral
  }
  comment 'Set _pid__numPIDs so pid_computePID can efficiently decide if the list needs to be extended'
  _pid__numPIDs = (size _pid__prevError)
}

to '_pid_initLibrary' {
  comment 'Create global lists.'
  if (not _pid__initialized) {
    _pid__prevError = (newList 0)
    _pid__prevMicros = (newList 0)
    _pid__prevIntegral = (newList 0)
    _pid__initialized = (booleanConstant true)
  }
}

to pid_applySign sign value {
  comment 'If sign < 0 return -value else return value'
  return (ifExpression (sign >= 0) value (0 - value))
}

to pid_computePID index error pCoeff iCoeff dCoeff maxIntegral {
  comment 'Compute the next PID value value, using inputs:
* index: index of the PID loop
* error: error to correct
* pCoeff: proportional coefficient (corr/error)
* iCoeff: integral coefficient (corr-msec/error)
* dCoeff: derivitive coefficient (corr/error-msec)
* maxIntegral: maximum absolute value of the integrated error; ignored if 0'
  if (_pid__numPIDs < index) {
    '_pid_extendPIDLists' index
  }
  local 'pValue' 0
  local 'iValue' 0
  local 'dValue' 0
  local 'integral' 0
  local 'currMicros' (microsOp)
  local 'prevMicros' (at index _pid__prevMicros)
  pValue = (pCoeff * error)
  if (prevMicros >= 0) {
    comment 'We have old data for this PID loop, so compute derivitive and integral contributions.'
    local 'deltaMicros' (microsSince prevMicros currMicros)
    local 'deltaErrorr' (error - (at index _pid__prevError))
    dValue = (((dCoeff * deltaErrorr) * 1000) / deltaMicros)
    integral = (((error * deltaMicros) / 1000) + (at index _pid__prevIntegral))
    if (and (maxIntegral > 0) ((absoluteValue integral) > maxIntegral)) {
      integral = (pid_applySign integral maxIntegral)
    }
    iValue = (iCoeff * integral)
  }
  atPut index _pid__prevMicros currMicros
  atPut index _pid__prevError error
  atPut index _pid__prevIntegral integral
  return (pValue + (iValue + dValue))
}

to pid_constrainValue value deadband minimum maximum {
  comment 'Constrain a value as follows:
If |value| < deadband: return 0.
If |value| < minimum: return minimum with sign of value.
If |value| > maximum: return maximum with sign of value.'
  local 'absValue' (absoluteValue value)
  if (absValue < deadband) {
    return 0
  } (absValue < minimum) {
    return (pid_applySign value minimum)
  } (absValue > maximum) {
    return (pid_applySign value maximum)
  } else {
    return value
  }
}

to pid_resetPID index {
  comment 'Zero the recorded error data for a specific PID loop.
Call this before starting each move, to avoid unwanted values
from the integral and derivitive terms.'
  if (_pid__numPIDs < index) {
    '_pid_extendPIDLists' index
  }
  atPut index _pid__prevError 0
  atPut index _pid__prevMicros -1
  atPut index _pid__prevIntegral 0
}


module 'Sentry2 AI camera' Input
author ShaoYue
version 1 8 
choices st2colorMenu red green blue yellow black white 
choices st2opMenu save del 
choices st2normalpropMenu X Y width heigh label 
choices st2modeMenu2 learning face 
choices st2cardMenu Forward Left Right TurnAround Park GreenLight RedLight Speed40 Speed60 Speed80 Check Cross Circle Square Triangle Plus Minus Divide Equal 
choices st2modeMenu color blob apriltag line learning card face '20class' 
choices st2linepropMenu topX topY bottomX bottomY angle 
description 'Sentry2 is a vision sensor which is designed by K210  
https://tosee.readthedocs.io/zh/latest/Sentry2/Vision/index.html
'
variables _st2_init_flag _st2_i2c_address _sentry2_card_label _st2_result_data _st2_mode_list _st2_color_tags _st2_current_mode _st2_normal_prop_label _st2_line_prop_label _st2_mode_settings 

  spec ' ' 'Sentry2 init' 'Sentry2 init _' 'num' 96
  spec ' ' 'Sentry turn' 'Sentry2 set mode _ _' 'menu.st2modeMenu bool' 'card' true
  spec 'r' 'Sentry2 mode' 'Sentry2 mode _' 'menu.st2modeMenu' 'card'
  spec 'r' 'Sentry2 get' 'Sentry2 get _ result' 'menu.st2modeMenu' 'card'
  spec 'r' 'Sentry2 detect card' 'Sentry2 detect card _ objid _' 'menu.st2cardMenu auto' 'Forward' 1
  spec 'r' 'Sentry2 detect color' 'Sentry2 detect color blob _ objid _' 'menu.st2colorMenu auto' 'red' 1
  spec 'r' 'Sentry detect normalobj' 'Sentry2 normalobj _ prop _' 'auto menu.st2normalpropMenu' 1 'X'
  spec 'r' 'Sentry2 detect lineobj' 'Sentry2 lineobj _ prop _' 'auto menu.st2linepropMenu' '1' 'topX'
  spec 'r' 'Sentry get color' 'Sentry2 get RGB color objid _' 'auto' 1
  spec 'r' 'sentry2_get_cardlabel' 'Sentry2 get card label by id _' 'auto' 1
  spec 'r' 'Sentry2 get color label' 'Sentry2 get color label by id _' 'auto' 1
  spec 'r' '_st2_get_u16' '_st2_get_u16 _' 'auto' '10'
  spec ' ' '_st2_sensor_reg_lock' '_st2_sensor_reg_lock _' 'bool' true
  spec 'r' '_st2_obj_data' '_st2_obj_data _' 'auto' 1
  spec 'r' '_st2_get_modeid' '_st2_modeid _' 'auto' 'apriltag'
  spec 'r' '_st2_get_label' '_st2_get_label _ index _' 'auto auto' 0 1
  spec 'r' 'Sentry2 get mode settings' 'Sentry2 get mode settings'
  spec ' ' '_sentry2_reset_kpu_modes' '_sentry2_reset_kpu_modes'
  spec 'r' 'Sentry2_detect_result' 'Sentry2 detect mode _' 'auto' 0
  spec 'r' 'Sentry get obj' 'Sentry2 get obj _ prop _' 'auto auto' 1 5
  spec ' ' 'set check blob color' 'set blob check color red _ green _ blue _' 'bool bool bool' true true true
  spec 'r' 'get dectect color obj ID' 'get dectect color obj ID _' 'menu.st2colorMenu' 'red'
  spec ' ' 'Sentry2 set param' 'Sentry2 _ param _ index _' 'menu.st2modeMenu2 menu.st2opMenu auto' 'learning' 'save' 1

to 'Sentry detect normalobj' objid foo {
  local 'var' ('[data:find]' foo _st2_normal_prop_label)
  if (var > 0) {
    return ('Sentry get obj' objid var)
  }
  return (booleanConstant false)
}

to 'Sentry get color' objid {
  if (and (objid > 0) (objid <= (Sentry2_detect_result 1))) {return (((at 1 (at objid _st2_result_data)) << 16) | (((at 2 (at objid _st2_result_data)) << 8) | (at 3 (at objid _st2_result_data))))}
  return (booleanConstant false)
}

to 'Sentry get obj' id foo {
  if (id <= (size _st2_result_data)) {return (ifExpression (foo <= (size (at id _st2_result_data))) (at foo (at id _st2_result_data)) 0)}
  return 0
}

to 'Sentry turn' mode foo {
  mode = ('_st2_get_modeid' mode)
  if (or (0 == _st2_i2c_address) (0 == mode)) {
    return 0
  } (and (or (3 == mode) (mode > 4)) foo) {
    '_sentry2_reset_kpu_modes'
  }
  i2cSet _st2_i2c_address (hexToInt '20') mode
  i2cSet _st2_i2c_address (hexToInt '21') (ifExpression foo 1 0)
  if foo {
    _st2_current_mode = mode
  } else {
    _st2_current_mode = 0
  }
}

to 'Sentry2 detect card' foo bar {
  if (and (bar > 0) (bar <= (Sentry2_detect_result 6))) {return (foo == (sentry2_get_cardlabel ('Sentry get obj' bar 5)))}
  return (booleanConstant false)
}

to 'Sentry2 detect color' foo bar {
  if (and (bar > 0) (bar <= (Sentry2_detect_result 2))) {return (foo == ('Sentry2 get color label' ('Sentry get obj' bar 5)))}
  return (booleanConstant false)
}

to 'Sentry2 detect lineobj' objid foo {
  local 'var' ('[data:find]' foo _st2_line_prop_label)
  if (var > 0) {
    return ('Sentry get obj' objid var)
  }
  return (booleanConstant false)
}

to 'Sentry2 get' mode {
  return (Sentry2_detect_result ('_st2_get_modeid' mode))
}

to 'Sentry2 get color label' foo {
  return ('_st2_get_label' _st2_color_tags foo)
}

to 'Sentry2 get mode settings' {
  local 'var' (i2cGet _st2_i2c_address (hexToInt '2A'))
  for i 8 {
    atPut i _st2_mode_settings ((var & (1 << (i - 1))) != 0)
  }
  return _st2_mode_settings
}

to 'Sentry2 init' foo {
  comment 'default i2c address 0x60 96'
  _st2_i2c_address = (minimum 99 (maximum 96 foo))
  _st2_mode_settings = (newList 8 (booleanConstant false))
  _st2_mode_list = ('[data:makeList]' 'color' 'blob' 'apriltag' 'line' 'learning' 'card' 'face' '20class')
  _st2_color_tags = ('[data:makeList]' 'black' 'white' 'red' 'green' 'blue' 'yellow')
  _sentry2_card_label = ('[data:split]' 'Forward,Left,Right,TurnAround,Park,GreenLight,RedLight,Speed40,Speed60,Speed80,Check,Cross,Circle,Square,Triangle,Plus,Minus,Divide,Equal,' ',')
  _st2_normal_prop_label = ('[data:makeList]' 'X' 'Y' 'width' 'heigh' 'label')
  _st2_line_prop_label = ('[data:makeList]' 'topX' 'topY' 'bottomX' 'bottomY' 'angle')
  if ((i2cGet _st2_i2c_address 1) == 4) {
    i2cSet _st2_i2c_address (hexToInt '04') ((i2cGet _st2_i2c_address (hexToInt '04')) | (hexToInt '08'))
    _st2_init_flag = 1
  }
}

to 'Sentry2 mode' mode {
  return (at ('_st2_get_modeid' mode) ('Sentry2 get mode settings'))
}

to 'Sentry2 set param' mode op id {
  if (or ('face' == mode) ('learning' == mode)) {
    'Sentry turn' mode true
    if (and (id >= 1) (id <= 25)) {
      i2cSet _st2_i2c_address (hexToInt '24') id
      i2cSet _st2_i2c_address (hexToInt '79') (ifExpression ('save' == op) 100 0)
    }
  }
}

to Sentry2_detect_result mode {
  comment '0 use current preset mode'
  if (mode == 0) {
    mode = _st2_current_mode
  }
  '_st2_sensor_reg_lock' true
  i2cSet _st2_i2c_address (hexToInt '20') mode
  comment 'detect count'
  local 'result_count' (i2cGet _st2_i2c_address (hexToInt '34'))
  if (0 != result_count) {
    _st2_result_data = (newList result_count)
    for i result_count {
      atPut i _st2_result_data ('_st2_obj_data' i)
    }
  } else {
    _st2_result_data = 0
  }
  '_st2_sensor_reg_lock' false
  return result_count
}

to '_sentry2_reset_kpu_modes' {
  for i ('[data:makeList]' 3 5 6 7 8) {
    i2cSet _st2_i2c_address (hexToInt '20') i
    i2cSet _st2_i2c_address (hexToInt '21') 0
    waitMillis 5
  }
}

to '_st2_get_label' label_list foo {
  if (isType label_list 'list') {if (and (foo > 0) (foo <= (size label_list))) {
    return (at foo label_list)
  }}
  return ''
}

to '_st2_get_modeid' foo {
  comment 'color,blob,apriltag,learning,card,face,20class,'
  local 'var' ('[data:find]' foo _st2_mode_list)
  return (ifExpression (var > 0) var 0)
}

to '_st2_get_u16' foo {
  return (((i2cGet _st2_i2c_address foo) << 8) | (i2cGet _st2_i2c_address (foo + 1)))
}

to '_st2_obj_data' obj_id {
  comment 'get dectect obj info by obj_id'
  i2cSet _st2_i2c_address (hexToInt '35') obj_id
  local 'var' (newList 5)
  for i 5 {
    atPut i var ('_st2_get_u16' ((hexToInt '80') + ((i - 1) * 2)))
  }
  return var
}

to '_st2_sensor_reg_lock' foo {
  if ((1 == (i2cGet _st2_i2c_address (hexToInt '05'))) == foo) {return 0}
  i2cSet _st2_i2c_address (hexToInt '05') (ifExpression foo 1 0)
}

to 'get dectect color obj ID' color {
  comment '获取识别到第一个对应颜色的ID'
  local 'var' ('Sentry2 get' 'blob')
  if (var >= 0) {
    for i var {
      if (('Sentry detect normalobj' i 'label') == ('[data:find]' color _st2_color_tags)) {return i}
    }
  }
  return 0
}

to sentry2_get_cardlabel foo {
  return ('_st2_get_label' _sentry2_card_label foo)
}

to 'set check blob color' red green blue {
  i2cSet _st2_i2c_address (hexToInt '20') ('_st2_get_modeid' 'blob')
  for i 6 {
    i2cSet _st2_i2c_address (hexToInt '24') i
    i2cSet _st2_i2c_address (hexToInt '79') 0
  }
  local 'var' 0
  if red {
    var += 1
    i2cSet _st2_i2c_address (hexToInt '24') var
    i2cSet _st2_i2c_address (hexToInt '79') 3
  }
  if green {
    var += 1
    i2cSet _st2_i2c_address (hexToInt '24') var
    i2cSet _st2_i2c_address (hexToInt '79') 4
  }
  if blue {
    var += 1
    i2cSet _st2_i2c_address (hexToInt '24') var
    i2cSet _st2_i2c_address (hexToInt '79') 5
  }
  if (var == 0) {
    var += 1
    i2cSet _st2_i2c_address (hexToInt '24') var
    i2cSet _st2_i2c_address (hexToInt '79') 3
  }
}


module Servo Output
author MicroBlocks
version 1 4 
tags servo motor angle rotation position 
description 'Control both positional (angle) and rotational servo motors.
'
variables _servoPin _servoPulseWidth 

  spec ' ' 'setServoAngle' 'set servo _ to _ degrees (-90 to 90)' 'num num' 1 90
  spec ' ' 'setServoSpeed' 'set servo _ to speed _ (-100 to 100)' 'num num' 1 100
  spec ' ' 'stopServo' 'stop servo _' 'num' 1
  spec 'r' '_servoIndex' '_servoIndex _' 'num' 1
  spec ' ' '_servoPulse' '_servoPulse pin _ usecs _' 'num num' 1 1500
  spec ' ' '_servoUpdateLoop' '_servoUpdateLoop'

to '_servoIndex' which {
  if (_servoPin == 0) {
    _servoPin = ('[data:makeList]')
    _servoPulseWidth = ('[data:makeList]')
    sendBroadcast '_servoUpdateLoop'
  }
  local 'i' ('[data:find]' which _servoPin)
  if (i < 0) {
    comment 'Add new pin'
    '[data:addLast]' which _servoPin
    '[data:addLast]' 1500 _servoPulseWidth
    i = (size _servoPin)
  }
  return i
}

to '_servoPulse' pin usecs {
  if (usecs == 0) {
    comment 'Servo stopped; do nothing'
    return 0
  }
  usecs = (maximum 500 (minimum usecs 2900))
  comment 'Split wait into a long wait followed by a wait of <= 30 usecs for greater accuracy'
  local 'endTime' ((microsOp) + usecs)
  digitalWriteOp pin true
  waitMicros (usecs - 30)
  waitMicros (endTime - (microsOp))
  digitalWriteOp pin false
}

to '_servoUpdateLoop' {
  forever {
    if (_servoPin != 0) {
      comment 'If the _servoPin list is not 0, update the servos'
      for i (size _servoPin) {
        local 'pin' (at i _servoPin)
        local 'usecs' (at i _servoPulseWidth)
        if (and (pin >= 0) (usecs != 0)) {
          '_servoPulse' pin usecs
        }
      }
      waitMillis 15
    }
  }
}

to setServoAngle which degrees optionalReverse {
  local 'reversed' false
  if ((pushArgCount) > 2) {
    reversed = optionalReverse
  }
  if reversed {
    degrees = (0 - degrees)
  }
  local 'pulseWidth' (1500 - (10 * degrees))
  if ('[io:hasServo]') {
    '[io:setServo]' which pulseWidth
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth pulseWidth
  }
}

to setServoSpeed which speed optionalReverse {
  local 'reversed' false
  if ((pushArgCount) > 2) {
    reversed = optionalReverse
  }
  if reversed {
    speed = (0 - speed)
  }
  local 'pulseWidth' (1500 - (10 * speed))
  if ((absoluteValue speed) < 2) {
    pulseWidth = 0
  }
  if ('[io:hasServo]') {
    '[io:setServo]' which pulseWidth
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth pulseWidth
  }
}

to stopServo which {
  if ('[io:hasServo]') {
    '[io:setServo]' which 0
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth 0
  }
}


module TFT Output
author MicroBlocks
version 1 12 
description 'Draw graphics and write text on boards with a TFT display, such as the M5Stack, M5Stick, Citilab ED1 or (discontinued) IoT-Bus.'

  spec ' ' '[tft:clear]' 'clear TFT display'
  space
  spec ' ' '[tft:rect]' 'draw rectangle on TFT at x _ y _ width _ height _ color _ : filled _' 'num num num num color bool' 10 10 40 30 nil true
  spec ' ' '[tft:roundedRect]' 'draw rounded rectangle on TFT at x _ y _ width _ height _ radius _ color _ : filled _' 'num num num num num color bool' 10 10 40 30 8 nil true
  spec ' ' '[tft:circle]' 'draw circle on TFT at x _ y _ radius _ color _ : filled _' 'num num num color bool' 40 40 30 nil true
  spec ' ' '[tft:triangle]' 'draw triangle on TFT at x _ y _ , x _ y _ , x _ y _ color _ : filled _' 'num num num num num num color bool' 20 20 30 80 60 5 nil true
  spec ' ' '[tft:line]' 'draw line on TFT from x _ y _ to x _ y _ color _' 'num num num num color' 12 8 25 15
  spec ' ' 'tft_drawVector' 'draw vector x _ y _ angle _ length _ color _' 'num num num num color' 40 40 45 40
  space
  spec ' ' '[tft:text]' 'write _ on TFT at x _ y _ color _ : scale _ wrap _ : bg color _' 'str num num color num bool color' 'Hello World!' 5 5 nil 2 true
  spec ' ' 'tft_drawText' 'draw text _ on TFT at x _ y _ color _ : scale _ : bg color _' 'str num num color num color' 'Line 1
Line 2' 50 20 nil 2
  space
  spec ' ' '[tft:setPixel]' 'set TFT pixel x _ y _ to _' 'num num color' 10 10
  spec ' ' '[tft:pixelRow]' 'draw pixel row _ x _ y _ : bytesPerPixel _ : palette _' 'auto num num num str' 'aList' 0 0 4
  spec ' ' '[tft:drawBitmap]' 'draw bitmap _ palette _ on TFT at x _ y _' 'str str num num' 'aBitmap' 'a list of colors' 10 10
  space
  spec 'r' 'tft_colorSwatch' '_' 'color'
  spec 'r' 'makeColor' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'makeGray' 'gray _ %' 'num' 50
  spec 'r' 'randomColor' 'random color'
  space
  spec 'r' '[tft:getWidth]' 'TFT width'
  spec 'r' '[tft:getHeight]' 'TFT height'
  space
  spec ' ' '[tft:setBacklight]' 'set TFT backlight _ (0-10)' 'num' 10
  space
  spec ' ' '_deferMonochromeDisplayUpdates' '_defer monochrome display updates'
  spec ' ' '_resumeMonochromeDisplayUpdates' '_resume monochrome display updates'

to '_deferMonochromeDisplayUpdates' {
  '[tft:deferUpdates]'
}

to '_resumeMonochromeDisplayUpdates' {
  '[tft:resumeUpdates]'
}

to makeColor r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return ((r << 16) | ((g << 8) | b))
}

to makeGray percent {
  gray = ((percent * 255) / 100)
  gray = (maximum 0 (minimum gray 255))
  return ((gray << 16) | ((gray << 8) | gray))
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to tft_colorSwatch color {
  return color
}

to tft_drawText s x y color optionalScale optionalBGColor {
  s = ('[data:convertType]' s 'string')
  local 'scale' (argOrDefault 5 2)
  local 'bgColor' (argOrDefault 6 '')
  local 'lines' ('[data:split]' s ('[data:unicodeString]' 10))
  for line ('[data:split]' s ('[data:unicodeString]' 10)) {
    if (isType bgColor 'number') {
      '[tft:text]' line x y color scale false bgColor
    } else {
      '[tft:text]' line x y color scale false
    }
    y += (8 * scale)
  }
}

to tft_drawVector x y angle length color {
  local 'endX' (x + ((length * ('[misc:sin]' (100 * (angle + 90)))) >> 14))
  local 'endY' (y + ((length * ('[misc:sin]' (100 * angle))) >> 14))
  '[tft:line]' x y endX endY color
}


module Tone Output
author MicroBlocks
version 1 10 
tags tone sound music audio note speaker 
choices tone_NoteName 'nt;c' 'nt;c#' 'nt;d' 'nt;d#' 'nt;e' 'nt;f' 'nt;f#' 'nt;g' 'nt;g#' 'nt;a' 'nt;a#' 'nt;b' 
description 'Audio tone generation. Make music with MicroBlocks!
'
variables _tonePin _toneInitalized _toneLoopOverhead _toneNoteNames _toneArezzoNotes _toneFrequencies 

  spec ' ' 'play tone' 'play note _ octave _ for _ ms' 'str.tone_NoteName num num' 'nt;c' 0 500
  spec ' ' 'playMIDIKey' 'play midi key _ for _ ms' 'num num' 60 500
  spec ' ' 'play frequency' 'play frequency _ for _ ms' 'num num' 261 500
  space
  spec ' ' 'startTone' 'start tone _ Hz' 'num' 440
  spec ' ' 'stopTone' 'stop tone'
  space
  spec ' ' 'attach buzzer to pin' 'attach buzzer to pin _' 'auto' ''
  space
  spec 'r' '_measureLoopOverhead' '_measureLoopOverhead'
  spec 'r' '_baseFreqForNote' '_baseFreqForNote _' 'auto' 'c'
  spec 'r' '_baseFreqForSemitone' '_baseFreqForSemitone _' 'num' 0
  spec ' ' '_toneLoop' '_toneLoop _ for _ ms' 'num num' 440000 100
  spec 'r' '_trimmedLowercase' '_trimmedLowercase _' 'str' 'A. b C...'
  spec ' ' '_tone init note names' '_tone init note names'

to '_baseFreqForNote' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case. Note names
may be followed by # for a sharp or b for a flat.'
  local 'normalized note' ('_trimmedLowercase' note)
  'normalized note' = (ifExpression ((at 1 (v 'normalized note')) == 'n') (v 'normalized note') ('[data:join]' 'nt;' (v 'normalized note')))
  '_tone init note names'
  if (('[data:find]' (v 'normalized note') _toneArezzoNotes) > 0) {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneArezzoNotes))
  } else {
    return ('_baseFreqForSemitone' ('[data:find]' (v 'normalized note') _toneNoteNames))
  }
}

to '_baseFreqForSemitone' semitone {
  if (_toneFrequencies == 0) {_toneFrequencies = ('[data:makeList]' 261626 277183 293665 311127 329628 349228 369994 391995 415305 440000 466164 493883 246942 277183 277183 311127 311127 349228 329628 369994 369994 415305 415305 466164 466164 523252)}
  if (and (1 <= semitone) (semitone <= (size _toneFrequencies))) {
    return (at semitone _toneFrequencies)
  } else {
    comment 'Bad note name; return 10 Hz'
    return 10000
  }
}

to '_measureLoopOverhead' {
  comment 'Measure the loop overhead on this device'
  local 'halfCycle' 100
  local 'startT' (microsOp)
  repeat 100 {
    digitalWriteOp _tonePin false
    waitMicros halfCycle
    digitalWriteOp _tonePin false
    waitMicros halfCycle
  }
  local 'usecs' ((microsOp) - startT)
  return ((usecs - 20000) / 200)
}

to '_tone init note names' {
  if (_toneNoteNames == 0) {
    _toneNoteNames = ('[data:makeList]' 'nt;c' 'nt;c#' 'nt;d' 'nt;d#' 'nt;e' 'nt;f' 'nt;f#' 'nt;g' 'nt;g#' 'nt;a' 'nt;a#' 'nt;b' 'nt;c_' 'nt;db' 'nt;d_' 'nt;eb' 'nt;e_' 'nt;e#' 'nt;f_' 'nt;gb' 'nt;g_' 'nt;ab' 'nt;a_' 'nt;bb' 'nt;b_' 'nt;b#')
    _toneArezzoNotes = ('[data:makeList]' 'nt;do' 'nt;do#' 'nt;re' 'nt;re#' 'nt;mi' 'nt;fa' 'nt;fa#' 'nt;sol' 'nt;sol#' 'nt;la' 'nt;la#' 'nt;si' 'nt;do_' 'nt;dob' 'nt;re_' 'nt;reb' 'nt;mi_' 'nt;mi#' 'nt;fa_' 'nt;solb' 'nt;sol_' 'nt;lab' 'nt;la_' 'nt;sib' 'nt;si_' 'nt;si#')
  }
}

to '_toneLoop' scaledFreq ms {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {
    '[io:playTone]' _tonePin (scaledFreq / 1000)
    waitMillis ms
    '[io:playTone]' _tonePin 0
  } else {
    local 'halfCycle' ((500000000 / scaledFreq) - _toneLoopOverhead)
    local 'cycles' ((ms * 500) / halfCycle)
    repeat cycles {
      digitalWriteOp _tonePin true
      waitMicros halfCycle
      digitalWriteOp _tonePin false
      waitMicros halfCycle
    }
  }
}

to '_trimmedLowercase' s {
  comment 'Return a copy of the given string without whitespace
or periods and all lowercase.'
  local 'result' (newList (size s))
  '[data:delete]' 'all' result
  for i (size s) {
    local 'ch' ('[data:unicodeAt]' i s)
    if (and (ch > 32) (ch != 46)) {
      if (and (65 <= ch) (ch <= 90)) {ch = (ch + 32)}
      '[data:addLast]' ch result
    }
  }
  return ('[data:unicodeString]' result)
}

to 'attach buzzer to pin' pinNumber {
  if (pinNumber == '') {
    comment 'Pin number not specified; use default pin for this device'
    if ((boardType) == 'Citilab ED1') {
      _tonePin = 26
    } ((boardType) == 'M5Stack-Core') {
      _tonePin = 25
    } ((boardType) == 'M5StickC') {
      _tonePin = 26
    } ((boardType) == 'Calliope') {
      digitalWriteOp 23 true
      digitalWriteOp 24 true
      _tonePin = 25
    } ((boardType) == 'D1-Mini') {
      _tonePin = 12
    } ((boardType) == 'CodingBox') {
      _tonePin = 32
    } else {
      _tonePin = -1
    }
  } else {
    _tonePin = pinNumber
  }
  _toneLoopOverhead = ('_measureLoopOverhead')
  _toneInitalized = (booleanConstant true)
}

to 'play frequency' freq ms {
  '_toneLoop' (freq * 1000) ms
}

to 'play tone' note octave ms {
  local 'freq' ('_baseFreqForNote' note)
  if (freq <= 10000) {
    waitMillis ms
    return 0
  }
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to playMIDIKey key ms {
  local 'freq' ('_baseFreqForSemitone' ((key % 12) + 1))
  local 'octave' ((key / 12) - 5)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  '_toneLoop' freq ms
}

to startTone freq {
  if (_toneInitalized == 0) {'attach buzzer to pin' ''}
  if ('[io:hasTone]') {'[io:playTone]' _tonePin freq}
}

to stopTone {
  startTone 0
}

